<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ribosome</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<h1>RIBOSOME</h1>

<p>A simple generic code generation tool</p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Documentation</h2>

<ul id="toc">
  <li><a href="#command-line">Command line</a></li>
  <li><a href="#simple-output">Simple output</a></li>
  <li><a href="#redirecting-output">Redirecting output</a></li>
  <li><a href="#embedded-expressions">Embedded expressions</a></li>
  <li><a href="#line-concatenation">Line concatenation</a></li>
  <li><a href="#separators">Separators</a></li>
  <li><a href="#strict-embedded-expressions">Strict embedded expressions</a></li>
  <li><a href="#nested-embedded-expressions">Nested embedded expressions</a></li>
  <li><a href="#escape-sequences">Escape sequences</a></li>
  <li><a href="#advanced-layout-management">Advanced layout management</a></li>
  <li><a href="#aligning-text">Aligning text</a></li>
  <li><a href="#generating-tabs">Generating tabs</a></li>
  <li><a href="#importing-dna-files">Importing DNA files</a></li>
  <li><a href="#distributing-the-code-generator">Distributing the code generator</a></li>
  <li><a href="#syntax-highlighting-in-vim">Syntax highlighting in Vim</a></li>
</ul>

<h3 id="command-line">Command line</h3>

<p>Ribosome command differs based on the control language one wishes to use.
For JavaScript it is <tt>ribosome.js</tt>, for Ruby it is <tt>ribosome.rb</tt>
and for Python it is <tt>ribosome.py</tt>.</p>

<p>Given that the input is a standard JavaScript, Ruby or Python program
(except for the lines starting with a dot) it is possible to just take your
existing program and run it with Ribosome. For example:</p>

<p class="lang">JavaScript:</p>
<pre>
$ ribosome.js foo.js
</pre>

<t>The arguments are passed unmodified to the program. Thus, if your
program takes three arguments, you can run it like this:</p>

<p class="lang">Ruby:</p>
<pre>
$ ribosome.rb foo.rb arg1 arg2 arg3
</pre>

<p>However, to distinguish native programs from Ribosome scripts it is customary
to add <tt>.dna</tt> extension to the script file. So the command line more
often  looks like this:</p>

<p class="lang">Python:</p>
<pre>
$ ribosome.py foo.py.dna arg1 arg2 arg3
</pre>

<h3 id="simple-output">Simple output</h3>

<p>Lines starting with a dot (.) are copied directly to the output:</p>

<p class="lang">JavaScript:</p>
<pre>
for(var i=0; i&lt;2; i++) {
.Test!
}
</pre>

<p class="lang">Ruby:</p>
<pre>
for i in 1..2
.Test!
end
</pre>

<p class="lang">Pyhon:</p>
<pre>
for i in range(2):
    .Test!
</pre>

<p>All the above scripts produce the same output:</p>

<pre>
Test!
Test!
</pre>

<p>Lines starting with a dot can be terminated by $ sign. The sign is optional,
however, if there's whitespace at the end of the line it is recommended to
finish the line with $ to prevent invisible whitespace getting into the output
files.</p>

<p class="lang">All languages:</p>
<pre>
.Hello!    $
</pre>

<h3 id="redirecting-output">Redirecting output</h3>

<p>By default, the output is directed to stdout. Therefore, it can be
re-directed using classic UNIX pipes. For example:</p>

<p class="lang">Ruby:</p>
<pre>
$ ribosome.rb test.rb.dna &gt; test.txt
</pre>

<p>You can also redirect the output to a specific destination directly from
the DNA file. Use '/!output' command to accomplish the task:</p>

<p class="lang">All languages:</p>
<pre>
.    /!output("test.txt")
.    Test!
</pre>

<p>Note that Ribosome commands may appear only in lines starting with a dot,
may be preceded with arbitrary amout of whitespace (which will be ignored) and
start with slash and exclamation mark. The arguments of the command are
standard expressions in the control language:</p>

<p class="lang">Python:</p>
<pre>
name = "foo"
./!output(name + ".txt")
</pre>

<p>To redirect the output back to the console use '/!stdout' command:</p>

<p class="lang">All languages:</p>
<pre>
./!output("test.txt")
.This line goes to the file!
./!stdout()
.This line goes to the console!
</pre>

<p>Finally, you can append new text to existing file using '/!append'
command:</p>

<p class="lang">All languages:</p>
<pre>
./!output("test.txt")
.Stuff
./!stdout()
./!append("test.txt")
.More stuff
</pre>

<h3 id="embedded-expressions">Embedded expressions</h3>

<p>Often, you need to insert a computed value into the output. You can do so by
embedding control language expressions into dot-style lines:</p>

<p class="lang">JavaScript:</p>
<pre>
var name = "Fred";
.Hello, @{name}!
</pre>

<p>With standard, non-Ribosome-aware functions, the return value is converted
into a string and written to the output.</p>

<p>If the embedded expression produces Ribosome output itself, the text is
inserted into the output file instead of the return value:</p>

<p class="lang">JavaScript:</p>
<pre>
function greet(name){
.printf ("Hello, @{name}!\n");
}

.int main () {
.    @{greet("Alice")}
.    @{greet("Bob")}
.    return 0;
.}
</pre>

<p class="lang">Ruby:</p>
<pre>
    def greet(name)
    .printf ("Hello, @{name}!\n");
    end

    .int main () {
    .    @{greet("Alice")}
    .    @{greet("Bob")}
    .    return 0;
    .}
</pre>

<p class="lang">Python:</p>
<pre>
def greet(name):
    .printf ("Hello, @{name}!\n");

.int main () {
.    @{greet("Alice")}
.    @{greet("Bob")}
.    return 0;
.}
</pre>

<h3 id="line-concatenation">Line concatenation</h3>

<p>Typically, each dot-style line is translated into a separate line in the
output file. Sometimes, however, you may want to generate complex stuff into
a single line of the output file. In such case new line can be appended directly
to the previous line. Use <tt>/+</tt> operator to achieve the behaviour:</p>

<p class="lang">JavaScript:</p>
<pre>
.Hello $
var students = ["Alice", "Bob", "Carol"];
students.forEach(function(item){
.   /+@{item} $
});
./+!
</pre>

<p class="lang">Ruby:</p>
<pre>
.Hello $
for i in ["Alice", "Bob", "Carol"]
.   /+@{i} $
end
./+!
</pre>

<p class="lang">Python:</p>
<pre>
.Hello $
for i in ["Alice", "Bob", "Carol"]:
    ./+@{i} $
./+!
</pre>

<p>Note that all the whitespace preceding <tt>/+</tt> operator is silently
ignored:</p>

<pre>
Hello Alice Bob Carol !
</pre>

<h3 id="separators">Separators</h3>

<p>A common task with code generation is to insert separators between the items
of a list. Ribosome provides <tt>/!separate</tt> command to help with the task.
The command must precede a loop (<tt>for</tt>, <tt>while</tt> or similar) and
takes a single parameter, the text to use as a separator:</p>

<p class="lang">JavaScript:</p>
<pre>
.Hello $
var students = ["Alice", "Bob", "Carol"];
./!separate(", ")
for(var i=0; i&lt;students.length; i++){
.   /+@{students[i]}
}
./+!
</pre>

<p class="lang">Ruby:</p>
<pre>
.Hello $
./!separate(", ")
for i in ["Alice", "Bob", "Carol"]
.   /+@{i}
end
./+!
</pre>

<p class="lang">Python:</p>
<pre>
.Hello $
./!separate(", ")
for i in ["Alice", "Bob", "Carol"]:
    .   /+@{i}
./+!
</pre>

<p>Note that the separator doesn't appear after the last element
of the list:</p>

<pre>
Hello Alice, Bob, Carol!
</pre>

<h3 id="strict-embedded-expressions">Strict embedded expressions</h3>

<p>You may have noticed that any whitespace generated by the embedded
expressions is trimmed. To keep the whitespace intact, use <tt>&amp;{}</tt>
operator instead of <tt>@{}</tt>:</p>

<p class="lang">Python:</p>
<pre>
s = " 2 "
.1@{s}3
.1&amp;{s}3
</pre>

<p>The script above produces following output:</p>

<pre>
123
1 2 3
</pre>

<h3 id="nested-embedded-expressions">Nested embedded expressions</h3>

<p>Producing output that is a DNA file itself can be tricky. The main problem is
that a lot of escape sequences would have to be used. To solve that, Ribosome
provides a tool called nested embedded expressions.</p>

<p>Nested embedded expressions are written <tt>@N{}</tt> or <tt>&amp;N{}</tt>,
where N is a digit from 1 to 9. The number is called the level of the nested
expression. During the compilation nested expressions of first level are
replaced by ordinary embedded expressions. Nested expressions of second level
are replaced by nested expressions of first level, nested expressions of third
level are replaced by nested expressions of second level and so on.</p>

<pre>
@9{x} =&gt; @8{x} =&gt; @7{x} =&gt; ... =&gt; @2{x} =&gt; @1{x} =&gt; @{x}
</pre>

<p>Consider, for exmaple, this script:</p>

<p class="lang">Ruby:</p>
<pre>
.name = "Alice"
..Hello, @1{name}!
</pre>

<p>It compiles into this script:</p>

<p class="lang">Ruby:</p>
<pre>
name = "Alice"
.Hello, @{name}!
</pre>

<p>Which, in turn, is compiled into:</p>

<pre>
Hello, Alice!
</pre>

<h3 id="escape-sequences">Escape sequences</h3>

<p>In the rare cases when you need to generate a sequence of characters that
accidentally matches a Ribosome operator, you can use one of the predefined
escape sequences. For example:</p>

<p class="lang">All languages:</p>
<pre>
.123@{at}{456
</pre>

<p>Translates into:</p>

<pre>
123@{456
</pre>

<p>Full list of escape sequences:</p>

<pre>
@{at} => @
@{amp} => &amp;
@{slash} => /
</pre>

<h3 id="advanced-layout-management">Advanced layout management</h3>

<p>Consider the following script:</p>

<p class="lang">JavaScipt:</p>
<pre>
function colours() {
.    White
.    Black
.    Ultramarine
.    Red
.    Green
.    Blue
}

function shapes() {
.    Triangle
.    Circle
}

.Colours: @{colours()} Shapes: @{shapes()}
.
.That's all, folks!
</pre>

<p>It produces the following output:</p>

<pre>
Colours: White       Shapes: Triangle
         Black               Circle
         Ultramarine
         Red
         Green
         Blue

That's all, folks!
</pre>

<p>To undestand how Ribosome layouts the code, it is necessary to keep in mind
that it's not characters that are placed on a line, but rather rectangular
blocks of text.</p>

<p>Every literal string is considered to be a block of text (consisting of
a single line) and so is every embedded expression. However, given that embedded
expressions can generate multiple lines they are treated as multi-line
blocks of text.</p>

<p>The blocks are aligned to the top of the line:</p>

<p>Thus, the line:</p>

<pre>
.Colours: @{colours()} Shapes: @{shapes()}
</pre>

<p>Is laid out like this:</p>

<img src="line.png"/>

<p>Every next line is laid out directly bellow the longest block on the previous
line:</p>

<img src="layout.png"/>

<p>Note that @-style embedded expressions trim the whitespace from the left,
right, top and bottom of the block. Therefore, the block produced by
<tt>@{colours}</tt> expression looks like this:</p>

<img src="block.png"/>

<p>Also note that whitespace is trimmed from the block as a whole, not from each
individual line. That way, the block alway remains rectangular in shape:</p>

<img src="block2.png"/>

<p>This feature is extremely important to produce properly aligned code.
Consider this example:</p>

<p class="lang">JavaScript:</p>
<pre>
function greet(name) {
.    printf ("Hello, @{name}!\n");
}

.@{greet("Alice")}
.if (is_bob_present) {
.    @{greet("Bob")}
.}
</pre>

<p>The script above produces following output:</p>

<pre>
printf ("Hello, Alice!\n");
if (is_bob_present) {
    printf ("Hello, Bob!\n");
}
</pre>

<p>Note how the greeting is properly aligned in both cases. What happens under
the hood is that the whitespace from line 2 of the script is trimmed by
<tt>@{}</tt> operator, while the whitespace on line 7 is treated as a text
literal (i.e. as one-line text block) and is appended to the line before
the greeting to Bob.</p>

<h3 id="aligning-text">Aligning text</h3>

</p>Operator <tt>/=</tt> aligns a line with the previous line.</p>

<p class="lang">All languages:</p>
<pre>
.        Hello,
./=world!
</pre>

<p>The above code yields the following output:</p>

<pre>
        Hello,
        world!
</pre>

<p>WARNING: This operator severely hurts the readability of the DNA script and
thus it should be avoided. There are some specific use cases though where proper
indentation of the generated code cannot be achieved by other means.
Specifically, if a block of code is fetched from an external source, e.g.
from an XML file, there's no way to know how it is indented. <tt>/=</tt>
operator can be then used to align subsequent code with this external block
of code.</p>

<h3 id="generating-tabs">Generating tabs</h3>

<p>Ribosome doesn't allow for tabs in the input, however, when generating
output it can, on demand, replace as much of the leading whitespace as possible
by tabs. To switch this functionality on use <tt>/!tabsize</tt> command,
providing desired size of the tab as a parameter:</p>

<p class="lang">All languages:</p>
<pre>
./!tabsize(4)
.for (i = 0; i != 10; ++i)
.    printf("Hi!\n");
.}
</pre>

<p>In the output, leading four spaces in the line 3 will be replaced
by a tab.</p>

<p>Set tabsize to zero to switch the generation of tabs off.</p>

<h3 id="importing-dna-files">Importing DNA files</h3>

<p>In case of need you can import a DNA file using <tt>/!include</tt> command.
The behaviour is the same as if the contents of the imported file was
copied to the location in question in the importing file:</p>

<p class="lang">All languages:</p>
<pre>
./!include("foo.dna")
</pre>

<h3 id="distributing-the-code-generator">Distributing the code generator</h3>

<p>Ribosome is a compiler-compiler. It first compiles DNA file into a straight
JavaScript, Ruby or Python program (called RNA script) which is then executed
to produce the generated code. The intermediate step is fully hidden from
the user.</p>

<p>The above works well for ad-hoc and throw-away code generation, however, if
you want to distribute the code generator to the users it is better to generate
the RNA script first and distribute that instead of the DNA script - that way
there's no dependency on Ribosome itself (the user will do with only
node.js, Ruby and/or Python installed):</p>

<p class="lang">Ruby:</p>
<pre>
ribosome.rb --rna foo.rb.dna &gt; foo.rb
</pre>

<p>Also note that if your DNA script is composed of multiple DNA files (using
<tt>/!include</tt> command) only a single RNA script is generated, making the
distribution to the users easier.</p>

<h3 id="syntax-highlighting-in-vim">Syntax highlighting in Vim</h3>

<p>Given that DNA files contain two overlapping indentations, syntax
highlighting is crucial for good code readability.</p>

<p>To install Ribosome syntax highlighting for vim, download the configuration
file here:</p>

<p><a class="download" href="https://raw.githubusercontent.com/sustrik/ribosome/f5562136eeaf81db7c2602fefaf6753564057612/ribosome.vim" download>ribosome.vim</a></p>

Copy it to the vim's syntax directory. For example:</p>

<pre>
sudo cp ribosome.vim /usr/share/vim/vim73/syntax
</pre>

<p>Afterwards, open vim's filetype file:</p>

<pre>
sudo vim /usr/share/vim/vim73/filetype.vim
</pre>

<p>And add the following line to it:</p>

<pre>
au BufNewFile,BufRead *.dna setf ribosome
</pre>

<p>Now you are ready to open a DNA file in vim:</p>

<img src="vim1.png"/>

<p>What you see is so called "common view" where control language (Ruby) and
generated language (C) are highlighted in such a way as to allow inspection
of both.</p>

<p>When in other views, you can switch to common view using F2 key.</p>

<p>Press F3 key to switch to the "Ruby view":</p>

<img src="vim2.png"/>

<p>Here the control language has its native syntax colouring, while generated
code is shaded as not to distract from inspecting the control language.</p>

<p>Press F4 key to switch to the "Output view":</p>

<img src="vim3.png"/>

<p>In this view the control language is shaded and output language is fully
visible.</p>

<p>However, vim does not know what syntax highlighting to use for the generated
language. You can instruct it to use particular syntax highlighting algorithm
using O (capital letter O) command. Pass the name of the language as an
argument:</p>

<img src="vim4.png"/>

</body>
</html>

